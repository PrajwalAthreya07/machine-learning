# -*- coding: utf-8 -*-
"""K_Nearest_neighbour.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JDK2V4JZm8rA1AZYTX4xavzukwASaMd_
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np  #for numerical calculations.
import pandas as pd #for datasets formulation in python.
import matplotlib.pyplot as plt  #for plotting graphs.
from sklearn.datasets import load_wine  #loading huge datasets.
from sklearn.model_selection import train_test_split

# %matplotlib inline

def euclid_distance(train_point , given_point): #function for defining the euclidian distance formula.
  distance = np.sum((train_point - given_point)**2)  #euclidian distance formula.
  return np.sqrt(distance)  #euclidian distance formula.

def calc_distance_from_all(all_points , given_point , predictions): #function to calculate distance from all points.
  all_distances = []
  for i, each in enumerate(all_points):
    distance = euclid_distance(each,given_point)
    all_distances.append((distance,int(predictions[i])))
  all_distances.sort(key=lambda tup:tup[0])
  return all_distances

def get_neighbours(distance,count):
  return distance[:count]

def predict(all_points , given_point , predictions): #all points are taken along with given points and predictions
  distances = calc_distance_from_all(all_points , given_point , predictions)
  neighbours = get_neighbours(distances , 6) #get distances from the nearest neighbours
  op = [row[1] for row in neighbours]
  predictions = max(set(op) , key = op.count) #op is set and count of op is set as well
  return predictions #returning prediction

def accuracy(basex ,basey , testx, testy):
  correct = 0
  for i in range(len(testx)):
    p = predict(basex , testx[i], basey)
    if p ==testy[i]:
      correct +=52
    return f"Accuracy : {correct*100 / len(testy)}%" #formula to print accuracy with % symbol

wine = load_wine() #loading wine data to variable wine
print(wine.DESCR)

x = pd.DataFrame(wine.data , columns = wine.feature_names)
y = pd.DataFrame(wine.target , columns = ["Target"])

x = (x-x.min())/(x.max()-x.min())
xtrain,xtest,ytrain , ytest = train_test_split(x,y,test_size = 0.3) #defining inputs x &y and explicitly giving inputs where 30% is test data and 70% is train data
wine.feature_names

f1 = 'hue'
f2 = 'proline'
basex = np.array(xtrain[[f1,f2]])
basey = np.array(ytrain)
xtest = np.array(xtest[[f1,f2]])
ytest = np.array(ytest)

x = pd.DataFrame(basex)
y = basey

plt.scatter(x.iloc[:,0],x.iloc[:,1],c=y , s=35)
plt.scatter(0.25,0.2,c='red',marker = 'x',s=300)

accuracy(basex,basey,xtest,ytest)